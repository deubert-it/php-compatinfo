{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About PHP CompatInfo is a library that can find the minimum version and the extensions required for a piece of code to run. Running on PHP greater or equal than 7.4 for parsing source code in a format PHP 5.2 to PHP 8.1 Features Parse source code in format PHP 5.2 to PHP 8.1 Detect PHP features for each Major/minor versions Detect versions of all directives, constants, functions, classes, interfaces of 100 extensions and more Display/Inspect list of extensions, and their versions supported Components Parsing PHP 5, PHP 7 or PHP 8 code into an abstract syntax tree (AST) is provided by the PHP-Parser library. Contextual elements and minimum PHP versions detection provided by following node visitors. PHP-Parser Node Visitors Parent references with the ParentContextVisitor Name Resolution with the NameResolverVisitor Version Resolution with the VersionResolverVisitor Profiler Data Collector(s) with common DataCollector and specialized VersionDataCollector classes Data Collector(s) contract with the CollectorInterface Collector Handler for both Profile and Profiler with CollectorTrait Profile information for a single data source with Profile Sniffs They are grouped by categories to solve PHP features (from 4.0 to 8.1) Arrays (3) Attributes (1) Classes (10) Constants (3) ControlStructures (4) Enumerations (1) Expressions (3) Fibers (1) FunctionDeclarations (7) Generators (1) Keywords (1) Numbers (2) Operators (5) TextProcessing (1) UseDeclarations (2) Extensions PHPCompatInfo can be extended by registering objects that implement one or more of the following interfaces: BeforeAnalysisInterface AfterAnalysisInterface BeforeFileAnalysisInterface AfterFileAnalysisInterface BeforeTraverseAstInterface AfterTraverseAstInterface BeforeProcessNodeInterface AfterProcessNodeInterface BeforeSetupSniffInterface AfterTearDownSniffInterface BeforeProcessSniffInterface AfterProcessSniffInterface Furthermore, extensions may implement the Symfony\\Component\\EventDispatcher\\EventSubscriberInterface in order to have its event handlers automatically registered with the EventDispatcher when the extension is loaded. Polyfills They are identified by services that implements the Bartlett\\CompatInfo\\Application\\Polyfills\\PolyfillInterface . Configuration(s) Load a config for CLI Application with the --config option. Read How to Load --config With Services in Symfony Console to learn more. Conditional Code Learn what code is consider as conditional, detected or not (with CompatInfo 5.4) Indirect calls Multiple signatures Other limitations Exclude folder(s) Sometimes you don't want to scan a certain directory while analysing data source. Learn how to do from console (CLI) or php script (API).","title":"Home"},{"location":"#about","text":"PHP CompatInfo is a library that can find the minimum version and the extensions required for a piece of code to run. Running on PHP greater or equal than 7.4 for parsing source code in a format PHP 5.2 to PHP 8.1","title":"About"},{"location":"#features","text":"Parse source code in format PHP 5.2 to PHP 8.1 Detect PHP features for each Major/minor versions Detect versions of all directives, constants, functions, classes, interfaces of 100 extensions and more Display/Inspect list of extensions, and their versions supported","title":"Features"},{"location":"#components","text":"Parsing PHP 5, PHP 7 or PHP 8 code into an abstract syntax tree (AST) is provided by the PHP-Parser library. Contextual elements and minimum PHP versions detection provided by following node visitors.","title":"Components"},{"location":"#php-parser-node-visitors","text":"Parent references with the ParentContextVisitor Name Resolution with the NameResolverVisitor Version Resolution with the VersionResolverVisitor","title":"PHP-Parser Node Visitors"},{"location":"#profiler","text":"Data Collector(s) with common DataCollector and specialized VersionDataCollector classes Data Collector(s) contract with the CollectorInterface Collector Handler for both Profile and Profiler with CollectorTrait Profile information for a single data source with Profile","title":"Profiler"},{"location":"#sniffs","text":"They are grouped by categories to solve PHP features (from 4.0 to 8.1) Arrays (3) Attributes (1) Classes (10) Constants (3) ControlStructures (4) Enumerations (1) Expressions (3) Fibers (1) FunctionDeclarations (7) Generators (1) Keywords (1) Numbers (2) Operators (5) TextProcessing (1) UseDeclarations (2)","title":"Sniffs"},{"location":"#extensions","text":"PHPCompatInfo can be extended by registering objects that implement one or more of the following interfaces: BeforeAnalysisInterface AfterAnalysisInterface BeforeFileAnalysisInterface AfterFileAnalysisInterface BeforeTraverseAstInterface AfterTraverseAstInterface BeforeProcessNodeInterface AfterProcessNodeInterface BeforeSetupSniffInterface AfterTearDownSniffInterface BeforeProcessSniffInterface AfterProcessSniffInterface Furthermore, extensions may implement the Symfony\\Component\\EventDispatcher\\EventSubscriberInterface in order to have its event handlers automatically registered with the EventDispatcher when the extension is loaded.","title":"Extensions"},{"location":"#polyfills","text":"They are identified by services that implements the Bartlett\\CompatInfo\\Application\\Polyfills\\PolyfillInterface .","title":"Polyfills"},{"location":"#configurations","text":"Load a config for CLI Application with the --config option. Read How to Load --config With Services in Symfony Console to learn more.","title":"Configuration(s)"},{"location":"#conditional-code","text":"Learn what code is consider as conditional, detected or not (with CompatInfo 5.4) Indirect calls Multiple signatures Other limitations","title":"Conditional Code"},{"location":"#exclude-folders","text":"Sometimes you don't want to scan a certain directory while analysing data source. Learn how to do from console (CLI) or php script (API).","title":"Exclude folder(s)"},{"location":"getting-started/","text":"Getting started Requirements PHP 7.4 or greater ext-json ext-libxml ext-pcre ext-spl PHPUnit 9 or greater (if you want to run unit tests) Generated with fork of clue/graph-composer . Read more on PR request . Installation With Composer Install the PHP CompatInfo with Composer . If you don't know yet what is composer, have a look on introduction . composer require bartlett/php-compatinfo ^6.4 With Git The PHP CompatInfo can be directly used from GitHub by cloning the repository into a directory of your choice. git clone -b 6 .4 https://github.com/llaville/php-compatinfo.git Configuring the Database The database connection information is stored as an environment variable called DATABASE_URL . # to use mysql: DATABASE_URL = \"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7\" # to use mariadb: DATABASE_URL = \"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8\" # to use sqlite: DATABASE_URL = \"sqlite:/// ${ HOME } /.cache/bartlett/compatinfo-db.sqlite\" # to use postgresql: DATABASE_URL = \"postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=11&charset=utf8\" After installation, or if you change database connection, you have to run following command(s): bin/phpcompatinfo db:create bin/phpcompatinfo db:init At first run of CompatInfoDB, DATABASE_URL will be set to use default SQLite connection Build PHAR distribution Uses the BOX Manifest to compile your PHAR version of application. Configuration file ( box.json.dist ) is provided with each release of phpCompatInfo.","title":"Getting-Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#requirements","text":"PHP 7.4 or greater ext-json ext-libxml ext-pcre ext-spl PHPUnit 9 or greater (if you want to run unit tests) Generated with fork of clue/graph-composer . Read more on PR request .","title":"Requirements"},{"location":"getting-started/#installation","text":"","title":"Installation"},{"location":"getting-started/#with-composer","text":"Install the PHP CompatInfo with Composer . If you don't know yet what is composer, have a look on introduction . composer require bartlett/php-compatinfo ^6.4","title":"With Composer"},{"location":"getting-started/#with-git","text":"The PHP CompatInfo can be directly used from GitHub by cloning the repository into a directory of your choice. git clone -b 6 .4 https://github.com/llaville/php-compatinfo.git","title":"With Git"},{"location":"getting-started/#configuring-the-database","text":"The database connection information is stored as an environment variable called DATABASE_URL . # to use mysql: DATABASE_URL = \"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=5.7\" # to use mariadb: DATABASE_URL = \"mysql://db_user:db_password@127.0.0.1:3306/db_name?serverVersion=mariadb-10.5.8\" # to use sqlite: DATABASE_URL = \"sqlite:/// ${ HOME } /.cache/bartlett/compatinfo-db.sqlite\" # to use postgresql: DATABASE_URL = \"postgresql://db_user:db_password@127.0.0.1:5432/db_name?serverVersion=11&charset=utf8\" After installation, or if you change database connection, you have to run following command(s): bin/phpcompatinfo db:create bin/phpcompatinfo db:init At first run of CompatInfoDB, DATABASE_URL will be set to use default SQLite connection","title":"Configuring the Database"},{"location":"getting-started/#build-phar-distribution","text":"Uses the BOX Manifest to compile your PHAR version of application. Configuration file ( box.json.dist ) is provided with each release of phpCompatInfo.","title":"Build PHAR distribution"},{"location":"01_Components/01_PHP-Parser/Visitors/","text":"Visitors ParentContextVisitor The AST does not store parent nodes by default. However, the ParentContextVisitor is used to achieve this in the following context: when elements are either class , interface , trait , function , closure , method , arrow function and property . The parent context visitor accepts an option array as the first argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ) that will store the parent node of only elements referenced above. The AST does not include a namespace node ( PhpParser\\Node\\Stmt\\Namespace_ ) when source code is only in global namespace. The second goal of ParentContextVisitor is to add this node at top of node list to traverse (during the beforeTraverse method). That will allow the CompatibilityAnalyser to show PHP versions required of full code in global namespace context. For example with such script: <?php declare ( strict_types = 1 ); function returnArray () { return [ 'one' , 'two' , 'three' ]; } $arrayValue1 = returnArray ()[ 0 ]; PHP versions detected are : 7.0.0 for full script, due to declare directive usage. 5.4.0 for short array usage in returnArray function. 5.4.0 for usage of array dereferencing syntax when calling returnArray function. NameResolverVisitor The NameResolverVisitor is applied to resolve names of each major elements where the PHP versions should be detected. It extends the basic Name Resolver by default that did not add namespacedName property on all elements. The name resolver accepts an option array as the second argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ) that reference the parent node of the following elements : class , interface , trait , function , closure , method , arrow function and property . After running this visitor, the parent node can be obtained through $node->getAttribute('bartlett.parent') . This will be useful with the CompatibilityAnalyser that should give PHP versions of each element including in their parent context. VersionResolverVisitor The VersionResolverVisitor is in charge to initialize PHP versions on each element ( namespace , class , interface , trait , function , closure , method or arrow function nodes) of source code context. The version resolver accepts an option array as the second argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ). Its value must be the same as the option used in the NameResolverVisitor . the nodeAttributeKeyStore option contains the name of a new node attribute (default to bartlett.data_collector ) that store the PHP versions of major elements. After running this visitor, the PHP versions can be obtained through $node->getAttribute('bartlett.data_collector') . This will be useful with the CompatibilityAnalyser . When user classes, interfaces or traits referenced extensions elements (with type hinting, parameters and return), it will call a local SQLite database to get information. Current database project supports all data for almost a hundred extensions on each PHP versions from 5.2.17 to latest 7.4 The version resolver accepts an instance of Bartlett\\CompatInfo\\Collection\\ReferenceCollectionInterface as the first argument. This collection referenced all information in the SQLite database. FilterVisitor The FilterVisitor is applied to retrieve all AST nodes that have attributes identified by nodeAttributeKeyStore option. Data in final format are retrieved by the FilterVisitor::getCollection() method. Data are normalized with the normalizer of the Symfony Serializer component, and transformed from internal format to final format by the NodeNormalizer of DataCollector. This visitor is used by the VersionDataCollector .","title":"Visitors"},{"location":"01_Components/01_PHP-Parser/Visitors/#visitors","text":"","title":"Visitors"},{"location":"01_Components/01_PHP-Parser/Visitors/#parentcontextvisitor","text":"The AST does not store parent nodes by default. However, the ParentContextVisitor is used to achieve this in the following context: when elements are either class , interface , trait , function , closure , method , arrow function and property . The parent context visitor accepts an option array as the first argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ) that will store the parent node of only elements referenced above. The AST does not include a namespace node ( PhpParser\\Node\\Stmt\\Namespace_ ) when source code is only in global namespace. The second goal of ParentContextVisitor is to add this node at top of node list to traverse (during the beforeTraverse method). That will allow the CompatibilityAnalyser to show PHP versions required of full code in global namespace context. For example with such script: <?php declare ( strict_types = 1 ); function returnArray () { return [ 'one' , 'two' , 'three' ]; } $arrayValue1 = returnArray ()[ 0 ]; PHP versions detected are : 7.0.0 for full script, due to declare directive usage. 5.4.0 for short array usage in returnArray function. 5.4.0 for usage of array dereferencing syntax when calling returnArray function.","title":"ParentContextVisitor"},{"location":"01_Components/01_PHP-Parser/Visitors/#nameresolvervisitor","text":"The NameResolverVisitor is applied to resolve names of each major elements where the PHP versions should be detected. It extends the basic Name Resolver by default that did not add namespacedName property on all elements. The name resolver accepts an option array as the second argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ) that reference the parent node of the following elements : class , interface , trait , function , closure , method , arrow function and property . After running this visitor, the parent node can be obtained through $node->getAttribute('bartlett.parent') . This will be useful with the CompatibilityAnalyser that should give PHP versions of each element including in their parent context.","title":"NameResolverVisitor"},{"location":"01_Components/01_PHP-Parser/Visitors/#versionresolvervisitor","text":"The VersionResolverVisitor is in charge to initialize PHP versions on each element ( namespace , class , interface , trait , function , closure , method or arrow function nodes) of source code context. The version resolver accepts an option array as the second argument, with the following default values: the nodeAttributeParentKeyStore option contains the name of a new node attribute (default to bartlett.parent ). Its value must be the same as the option used in the NameResolverVisitor . the nodeAttributeKeyStore option contains the name of a new node attribute (default to bartlett.data_collector ) that store the PHP versions of major elements. After running this visitor, the PHP versions can be obtained through $node->getAttribute('bartlett.data_collector') . This will be useful with the CompatibilityAnalyser . When user classes, interfaces or traits referenced extensions elements (with type hinting, parameters and return), it will call a local SQLite database to get information. Current database project supports all data for almost a hundred extensions on each PHP versions from 5.2.17 to latest 7.4 The version resolver accepts an instance of Bartlett\\CompatInfo\\Collection\\ReferenceCollectionInterface as the first argument. This collection referenced all information in the SQLite database.","title":"VersionResolverVisitor"},{"location":"01_Components/01_PHP-Parser/Visitors/#filtervisitor","text":"The FilterVisitor is applied to retrieve all AST nodes that have attributes identified by nodeAttributeKeyStore option. Data in final format are retrieved by the FilterVisitor::getCollection() method. Data are normalized with the normalizer of the Symfony Serializer component, and transformed from internal format to final format by the NodeNormalizer of DataCollector. This visitor is used by the VersionDataCollector .","title":"FilterVisitor"},{"location":"01_Components/02_Profiler/Collectors/","text":"Profiler The Profiler Component of new architecture 5.4 gets its information using services called \"DataCollector\". This is the same data collected during source code analysis that are passed to different views displayed to the User. Data Collectors While walking the AST, different visitors will initialize context and capture results of the PHP versions detected of all elements (namespaces, classes, interfaces, traits, methods, functions, constants). At the end of parsing a source file, the afterTraverse() method calls the Profiler and each collector attached to it. These \"DataCollectors\" that must implement DataCollectorInterface contract will retrieve information written in AST nodes that have an nodeAttributeKeyStore attribute. The VersionDataCollector is a specific data collector to CompatibilityAnalyser . VersionDataCollector The VersionDataCollector is in charge to initialize minimum PHP versions of all major elements (namespaces, classes, interfaces, traits, methods, functions, constants) of a source file.","title":"Data Collectors"},{"location":"01_Components/02_Profiler/Collectors/#profiler","text":"The Profiler Component of new architecture 5.4 gets its information using services called \"DataCollector\". This is the same data collected during source code analysis that are passed to different views displayed to the User.","title":"Profiler"},{"location":"01_Components/02_Profiler/Collectors/#data-collectors","text":"While walking the AST, different visitors will initialize context and capture results of the PHP versions detected of all elements (namespaces, classes, interfaces, traits, methods, functions, constants). At the end of parsing a source file, the afterTraverse() method calls the Profiler and each collector attached to it. These \"DataCollectors\" that must implement DataCollectorInterface contract will retrieve information written in AST nodes that have an nodeAttributeKeyStore attribute. The VersionDataCollector is a specific data collector to CompatibilityAnalyser .","title":"Data Collectors"},{"location":"01_Components/02_Profiler/Collectors/#versiondatacollector","text":"The VersionDataCollector is in charge to initialize minimum PHP versions of all major elements (namespaces, classes, interfaces, traits, methods, functions, constants) of a source file.","title":"VersionDataCollector"},{"location":"01_Components/03_Sniffs/Features/","text":"Sniffs Before version 5.4, PHP CompatInfo and its compatibility analyser was monolithic code. Since version 5.4, PHP CompatInfo used a sniff architecture that simplify maintainability of existing code and allows to extend it more easily. Each sniff, is in charge to detect a PHP language feature. Here is the list of features supported and their corresponding sniffs : PHP 5.0 Sniff category Sniff class name PHP Feature Classes MethodDeclarationSniff Method Visibility Classes PropertyDeclarationSniff Properties PHP 5.1 Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods PHP 5.2 Sniff category Sniff class name PHP Feature PHP 5.3 Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods Classes DynamicAccessSniff Dynamic Static Method access Classes DynamicAccessSniff Dynamic Static Property access ControlStructures DeclareSniff declare ControlStructures GotoSniff goto FunctionDeclarations ClosureSniff Anonymous functions VersionResolverVisitor Closures Operators ShortTernaryOperatorSniff Ternary Operator VersionResolverVisitor Namespaces TextProcessing CryptStringSniff CRYPT_BLOWFISH security fix details PHP 5.4 Sniff category Sniff class name PHP Feature Arrays ArrayDereferencingSyntaxSniff Array dereferencing Arrays ShortArraySyntaxSniff Short array syntax Classes ClassMemberAccessSniff Class member access on instantiation Expressions ClassExprSyntaxSniff Class::{expr}() syntax Numbers BinaryNumberFormatSniff Binary number format UseDeclarations UseTraitSniff Traits VersionResolverVisitor Traits PHP 5.5 Sniff category Sniff class name PHP Feature Constants MagicClassConstantSniff ::class syntax Expressions EmptySniff empty() supports arbitrary expressions Generators GeneratorSniff Generators PHP 5.6 Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods Constants ConstSyntaxSniff Contant Expressions Operators PowOperatorSniff Exponentiation UseDeclarations UseConstFunctionSniff use function and use const PHP 7.0 Sniff category Sniff class name PHP Feature FunctionDeclarations ParamTypeDeclarationSniff Scalar type declarations FunctionDeclarations ReturnTypeDeclarationSniff Return type declarations Keywords ReservedSniff Scalar type declarations Operators NullCoalesceOperatorSniff Null coalescing operator Operators CombinedComparisonOperatorSniff Spaceship operator Constant arrays using define() Classes AnonymousClassSniff Anonymous classes Classes ClassMemberAccessSniff Class member access on cloning ControlStructures DeclareSniff declare Generators GeneratorSniff Generator Return Expressions Generators GeneratorSniff Generator Delegation PHP 7.1 Sniff category Sniff class name PHP Feature FunctionDeclarations ParamTypeDeclarationSniff Nullable types FunctionDeclarations ReturnTypeDeclarationSniff Nullable types FunctionDeclarations ReturnTypeDeclarationSniff Void functions Symmetric array destructuring Class constant visibility FunctionDeclarations ParamTypeDeclarationSniff iterable pseudo-type Keywords ReservedSniff iterable pseudo-type Multi catch exception handling Support for keys in list() PHP 7.2 Sniff category Sniff class name PHP Feature Keywords ReservedSniff New object type PHP 7.3 Sniff category Sniff class name PHP Feature PHP 7.4 Sniff category Sniff class name PHP Feature Arrays ArrayUnpackingSyntaxSniff Array unpacking support for numeric-keyed arrays Classes TypedPropertySniff Typed properties FunctionDeclarations ArrowFunctionSniff Arrow functions VersionResolverVisitor Arrow functions PHP 8.0 Sniff category Sniff class name PHP Feature Attributes AttributeSniff Attributes Classes PropertyPromotionSniff Constructor property promotion ControlStructures MatchSniff Match expressions ControlStructures NonCapturingCatchSniff Non-capturing catches FunctionDeclarations NamedArgumentDeclarationSniff Named arguments FunctionDeclarations ParamTypeDeclarationSniff Union types FunctionDeclarations TrailingCommaSniff Trailing comma Operators NullsafeOperatorSniff Nullsafe operator PHP 8.1 Sniff category Sniff class name PHP Feature Arrays ArrayUnpackingSyntaxSniff Array unpacking support for string-keyed arrays Classes ReadonlyPropertySniff Readonly Properties Classes NewInitializerSniff New initializers Constants ClassConstantSniff Final class constants Enumerations EnumerationSniff Enumerations Fibers FiberSniff Fibers FunctionDeclarations FirstClassCallableSniff First class callable FunctionDeclarations ParamTypeDeclarationSniff Pure Intersection Types FunctionDeclarations ReturnTypeDeclarationSniff Pure Intersection Types FunctionDeclarations ReturnTypeDeclarationSniff Never return type Numbers OctalNumberFormatSniff Explicit Octal numeral notation Special cases Namespaces declaration have no sniff, because its detected by the VersionResolverVisitor Classes declaration have no sniff, because its detected by the VersionResolverVisitor Interfaces declaration have no sniff, because its detected by the VersionResolverVisitor Traits declaration have no sniff, because its detected by the VersionResolverVisitor Closures are initialized by the VersionResolverVisitor and keywords (this, self, parent, static) are detected with ClosureSniff Arrow functions have no sniff, because its detected by the VersionResolverVisitor , but has its test case with ArrowFunctionSniffTest","title":"Sniffs"},{"location":"01_Components/03_Sniffs/Features/#sniffs","text":"Before version 5.4, PHP CompatInfo and its compatibility analyser was monolithic code. Since version 5.4, PHP CompatInfo used a sniff architecture that simplify maintainability of existing code and allows to extend it more easily. Each sniff, is in charge to detect a PHP language feature. Here is the list of features supported and their corresponding sniffs :","title":"Sniffs"},{"location":"01_Components/03_Sniffs/Features/#php-50","text":"Sniff category Sniff class name PHP Feature Classes MethodDeclarationSniff Method Visibility Classes PropertyDeclarationSniff Properties","title":"PHP 5.0"},{"location":"01_Components/03_Sniffs/Features/#php-51","text":"Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods","title":"PHP 5.1"},{"location":"01_Components/03_Sniffs/Features/#php-52","text":"Sniff category Sniff class name PHP Feature","title":"PHP 5.2"},{"location":"01_Components/03_Sniffs/Features/#php-53","text":"Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods Classes DynamicAccessSniff Dynamic Static Method access Classes DynamicAccessSniff Dynamic Static Property access ControlStructures DeclareSniff declare ControlStructures GotoSniff goto FunctionDeclarations ClosureSniff Anonymous functions VersionResolverVisitor Closures Operators ShortTernaryOperatorSniff Ternary Operator VersionResolverVisitor Namespaces TextProcessing CryptStringSniff CRYPT_BLOWFISH security fix details","title":"PHP 5.3"},{"location":"01_Components/03_Sniffs/Features/#php-54","text":"Sniff category Sniff class name PHP Feature Arrays ArrayDereferencingSyntaxSniff Array dereferencing Arrays ShortArraySyntaxSniff Short array syntax Classes ClassMemberAccessSniff Class member access on instantiation Expressions ClassExprSyntaxSniff Class::{expr}() syntax Numbers BinaryNumberFormatSniff Binary number format UseDeclarations UseTraitSniff Traits VersionResolverVisitor Traits","title":"PHP 5.4"},{"location":"01_Components/03_Sniffs/Features/#php-55","text":"Sniff category Sniff class name PHP Feature Constants MagicClassConstantSniff ::class syntax Expressions EmptySniff empty() supports arbitrary expressions Generators GeneratorSniff Generators","title":"PHP 5.5"},{"location":"01_Components/03_Sniffs/Features/#php-56","text":"Sniff category Sniff class name PHP Feature Classes MagicMethodsSniff Magic Methods Constants ConstSyntaxSniff Contant Expressions Operators PowOperatorSniff Exponentiation UseDeclarations UseConstFunctionSniff use function and use const","title":"PHP 5.6"},{"location":"01_Components/03_Sniffs/Features/#php-70","text":"Sniff category Sniff class name PHP Feature FunctionDeclarations ParamTypeDeclarationSniff Scalar type declarations FunctionDeclarations ReturnTypeDeclarationSniff Return type declarations Keywords ReservedSniff Scalar type declarations Operators NullCoalesceOperatorSniff Null coalescing operator Operators CombinedComparisonOperatorSniff Spaceship operator Constant arrays using define() Classes AnonymousClassSniff Anonymous classes Classes ClassMemberAccessSniff Class member access on cloning ControlStructures DeclareSniff declare Generators GeneratorSniff Generator Return Expressions Generators GeneratorSniff Generator Delegation","title":"PHP 7.0"},{"location":"01_Components/03_Sniffs/Features/#php-71","text":"Sniff category Sniff class name PHP Feature FunctionDeclarations ParamTypeDeclarationSniff Nullable types FunctionDeclarations ReturnTypeDeclarationSniff Nullable types FunctionDeclarations ReturnTypeDeclarationSniff Void functions Symmetric array destructuring Class constant visibility FunctionDeclarations ParamTypeDeclarationSniff iterable pseudo-type Keywords ReservedSniff iterable pseudo-type Multi catch exception handling Support for keys in list()","title":"PHP 7.1"},{"location":"01_Components/03_Sniffs/Features/#php-72","text":"Sniff category Sniff class name PHP Feature Keywords ReservedSniff New object type","title":"PHP 7.2"},{"location":"01_Components/03_Sniffs/Features/#php-73","text":"Sniff category Sniff class name PHP Feature","title":"PHP 7.3"},{"location":"01_Components/03_Sniffs/Features/#php-74","text":"Sniff category Sniff class name PHP Feature Arrays ArrayUnpackingSyntaxSniff Array unpacking support for numeric-keyed arrays Classes TypedPropertySniff Typed properties FunctionDeclarations ArrowFunctionSniff Arrow functions VersionResolverVisitor Arrow functions","title":"PHP 7.4"},{"location":"01_Components/03_Sniffs/Features/#php-80","text":"Sniff category Sniff class name PHP Feature Attributes AttributeSniff Attributes Classes PropertyPromotionSniff Constructor property promotion ControlStructures MatchSniff Match expressions ControlStructures NonCapturingCatchSniff Non-capturing catches FunctionDeclarations NamedArgumentDeclarationSniff Named arguments FunctionDeclarations ParamTypeDeclarationSniff Union types FunctionDeclarations TrailingCommaSniff Trailing comma Operators NullsafeOperatorSniff Nullsafe operator","title":"PHP 8.0"},{"location":"01_Components/03_Sniffs/Features/#php-81","text":"Sniff category Sniff class name PHP Feature Arrays ArrayUnpackingSyntaxSniff Array unpacking support for string-keyed arrays Classes ReadonlyPropertySniff Readonly Properties Classes NewInitializerSniff New initializers Constants ClassConstantSniff Final class constants Enumerations EnumerationSniff Enumerations Fibers FiberSniff Fibers FunctionDeclarations FirstClassCallableSniff First class callable FunctionDeclarations ParamTypeDeclarationSniff Pure Intersection Types FunctionDeclarations ReturnTypeDeclarationSniff Pure Intersection Types FunctionDeclarations ReturnTypeDeclarationSniff Never return type Numbers OctalNumberFormatSniff Explicit Octal numeral notation","title":"PHP 8.1"},{"location":"01_Components/03_Sniffs/Features/#special-cases","text":"Namespaces declaration have no sniff, because its detected by the VersionResolverVisitor Classes declaration have no sniff, because its detected by the VersionResolverVisitor Interfaces declaration have no sniff, because its detected by the VersionResolverVisitor Traits declaration have no sniff, because its detected by the VersionResolverVisitor Closures are initialized by the VersionResolverVisitor and keywords (this, self, parent, static) are detected with ClosureSniff Arrow functions have no sniff, because its detected by the VersionResolverVisitor , but has its test case with ArrowFunctionSniffTest","title":"Special cases"},{"location":"01_Components/04_Extensions/Hooks/","text":"Registering Extensions If you are using the config/set/default.php configuration file, your extension classes are already registered as services . <?php use Bartlett\\CompatInfo\\Application\\Extension\\ExtensionInterface ; use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator ; return static function ( ContainerConfigurator $containerConfigurator ) : void { $services = $containerConfigurator -> services (); $services -> instanceof ( ExtensionInterface :: class ) -> tag ( 'app.extension' ) ; } Hooks CompatInfo Extensions may implement one or more of these interfaces: BeforeAnalysisInterface - called before CompatInfo begins to run analysis. AfterAnalysisInterface - called after CompatInfo has completed its analysis. Use this hook if you want to do something with the analysis results. BeforeFileAnalysisInterface - called before CompatInfo analyzes a file. AfterFileAnalysisInterface - called after CompatInfo analyzes a file. BeforeTraverseAstInterface - called once before AST traversal. AfterTraverseAstInterface - called once after AST traversal. BeforeProcessNodeInterface - called before entering a node. AfterProcessNodeInterface - called after leaving a node. BeforeSetupSniffInterface - called before initializes a sniff. AfterTearDownSniffInterface - called after tear down a sniff. BeforeProcessSniffInterface - called before entering a sniff. AfterProcessSniffInterface - called after leaving a sniff. Furthermore extensions may implement the Symfony\\Component\\EventDispatcher\\EventSubscriberInterface . See built-in extensions Application\\Extension\\Logger and Application\\Extension\\ProgressBar as examples.","title":"Extensions"},{"location":"01_Components/04_Extensions/Hooks/#registering-extensions","text":"If you are using the config/set/default.php configuration file, your extension classes are already registered as services . <?php use Bartlett\\CompatInfo\\Application\\Extension\\ExtensionInterface ; use Symfony\\Component\\DependencyInjection\\Loader\\Configurator\\ContainerConfigurator ; return static function ( ContainerConfigurator $containerConfigurator ) : void { $services = $containerConfigurator -> services (); $services -> instanceof ( ExtensionInterface :: class ) -> tag ( 'app.extension' ) ; }","title":"Registering Extensions"},{"location":"01_Components/04_Extensions/Hooks/#hooks","text":"CompatInfo Extensions may implement one or more of these interfaces: BeforeAnalysisInterface - called before CompatInfo begins to run analysis. AfterAnalysisInterface - called after CompatInfo has completed its analysis. Use this hook if you want to do something with the analysis results. BeforeFileAnalysisInterface - called before CompatInfo analyzes a file. AfterFileAnalysisInterface - called after CompatInfo analyzes a file. BeforeTraverseAstInterface - called once before AST traversal. AfterTraverseAstInterface - called once after AST traversal. BeforeProcessNodeInterface - called before entering a node. AfterProcessNodeInterface - called after leaving a node. BeforeSetupSniffInterface - called before initializes a sniff. AfterTearDownSniffInterface - called after tear down a sniff. BeforeProcessSniffInterface - called before entering a sniff. AfterProcessSniffInterface - called after leaving a sniff. Furthermore extensions may implement the Symfony\\Component\\EventDispatcher\\EventSubscriberInterface . See built-in extensions Application\\Extension\\Logger and Application\\Extension\\ProgressBar as examples.","title":"Hooks"},{"location":"01_Components/04_Extensions/Reporter/","text":"Output format Since version 6.1.0 , PHP CompatInfo supports different output formats through various formatters. You can pass the following keywords to the --output CLI option of the analyser:run command in order to affect the output: console : default table format for human reading. dump : raw format ( var_dump ) for debugging purpose only. json : creates minified json file format output without whitespaces. sarif : creates a S tatic A nalysis R esults I nterchange F ormat to share results with other tools or applications You can also implement your own custom formatter by implementing the Bartlett\\CompatInfo\\Application\\Extension\\Reporter\\FormatterInterface interface in a new class. This is how the FormatterInterface interface looks like: <?php declare ( strict_types = 1 ); namespace Bartlett\\CompatInfo\\Application\\Extension\\Reporter ; interface FormatterInterface { /** * @param object $object * @param string[] $formats * @return bool */ public function supportsFormatting ( object $object , array $formats ) : bool ; /** * @param mixed $data Data to format * @return void */ public function format ( $data ) : void ; } Before you can start using your custom output formatter, you have to include it in a new class that implement the Bartlett\\CompatInfo\\Application\\Extension\\ExtensionInterface interface (see Registering Extensions chapter for details). ConsoleReporter is a good first example to follow.","title":"Output format"},{"location":"01_Components/04_Extensions/Reporter/#output-format","text":"Since version 6.1.0 , PHP CompatInfo supports different output formats through various formatters. You can pass the following keywords to the --output CLI option of the analyser:run command in order to affect the output: console : default table format for human reading. dump : raw format ( var_dump ) for debugging purpose only. json : creates minified json file format output without whitespaces. sarif : creates a S tatic A nalysis R esults I nterchange F ormat to share results with other tools or applications You can also implement your own custom formatter by implementing the Bartlett\\CompatInfo\\Application\\Extension\\Reporter\\FormatterInterface interface in a new class. This is how the FormatterInterface interface looks like: <?php declare ( strict_types = 1 ); namespace Bartlett\\CompatInfo\\Application\\Extension\\Reporter ; interface FormatterInterface { /** * @param object $object * @param string[] $formats * @return bool */ public function supportsFormatting ( object $object , array $formats ) : bool ; /** * @param mixed $data Data to format * @return void */ public function format ( $data ) : void ; } Before you can start using your custom output formatter, you have to include it in a new class that implement the Bartlett\\CompatInfo\\Application\\Extension\\ExtensionInterface interface (see Registering Extensions chapter for details). ConsoleReporter is a good first example to follow.","title":"Output format"},{"location":"01_Components/05_Polyfills/Features/","text":"Polyfills Before version 6.4, PHP CompatInfo and its compatibility analyser was not able to detect packages that provides compatibility layers for some extensions and functions. Since version 6.4, PHP CompatInfo used a polyfill architecture to detect such packages that backports features found in the latest PHP versions. Each polyfill package must be supported both with PHP CompatInfoDB (since release 4.2.0) to identify PHP features (classes, constants, functions), and CompatInfo itself by services implementing the Bartlett\\CompatInfo\\Application\\Polyfills\\PolyfillInterface Here is the list of available polyfill services supported (namespace Bartlett\\CompatInfo\\Application\\Polyfills ) : Ctype extension Polyfill class name Description SymfonyCtype This polyfill detects PHP native ctype_* functions to users who run php versions without the ctype extension Available since release 6.4.0 Iconv extension Polyfill class name Description SymfonyIconv This polyfill detects PHP native iconv_* functions to users who run php versions without the iconv extension Available since release 6.4.0 Mbstring extension Polyfill class name Description SymfonyMbstring This polyfill detects PHP native mb_* functions to users who run php versions without the mbstring extension Available since release 6.4.0 PHP 7.0 Polyfill class name Description SymfonyPhp70 This polyfill detects features unavailable in releases prior to PHP 7.0 Available since release 6.4.0 PHP 7.1 Polyfill class name Description SymfonyPhp71 This polyfill detects features unavailable in releases prior to PHP 7.1 Available since release 6.4.0 PHP 7.2 Polyfill class name Description SymfonyPhp72 This polyfill detects features unavailable in releases prior to PHP 7.2 Available since release 6.4.0 PHP 7.3 Polyfill class name Description SymfonyPhp73 This polyfill detects features unavailable in releases prior to PHP 7.3 Available since release 6.4.0 PHP 7.4 Polyfill class name Description SymfonyPhp74 This polyfill detects features unavailable in releases prior to PHP 7.4 Available since release 6.4.0 PHP 8.0 Polyfill class name Description SymfonyPhp80 This polyfill detects features unavailable in releases prior to PHP 8.0 Available since release 6.4.0 PHP 8.1 Polyfill class name Description SymfonyPhp81 This polyfill detects features unavailable in releases prior to PHP 8.1 Available since release 6.4.0","title":"Features"},{"location":"01_Components/05_Polyfills/Features/#polyfills","text":"Before version 6.4, PHP CompatInfo and its compatibility analyser was not able to detect packages that provides compatibility layers for some extensions and functions. Since version 6.4, PHP CompatInfo used a polyfill architecture to detect such packages that backports features found in the latest PHP versions. Each polyfill package must be supported both with PHP CompatInfoDB (since release 4.2.0) to identify PHP features (classes, constants, functions), and CompatInfo itself by services implementing the Bartlett\\CompatInfo\\Application\\Polyfills\\PolyfillInterface Here is the list of available polyfill services supported (namespace Bartlett\\CompatInfo\\Application\\Polyfills ) :","title":"Polyfills"},{"location":"01_Components/05_Polyfills/Features/#ctype-extension","text":"Polyfill class name Description SymfonyCtype This polyfill detects PHP native ctype_* functions to users who run php versions without the ctype extension Available since release 6.4.0","title":"Ctype extension"},{"location":"01_Components/05_Polyfills/Features/#iconv-extension","text":"Polyfill class name Description SymfonyIconv This polyfill detects PHP native iconv_* functions to users who run php versions without the iconv extension Available since release 6.4.0","title":"Iconv extension"},{"location":"01_Components/05_Polyfills/Features/#mbstring-extension","text":"Polyfill class name Description SymfonyMbstring This polyfill detects PHP native mb_* functions to users who run php versions without the mbstring extension Available since release 6.4.0","title":"Mbstring extension"},{"location":"01_Components/05_Polyfills/Features/#php-70","text":"Polyfill class name Description SymfonyPhp70 This polyfill detects features unavailable in releases prior to PHP 7.0 Available since release 6.4.0","title":"PHP 7.0"},{"location":"01_Components/05_Polyfills/Features/#php-71","text":"Polyfill class name Description SymfonyPhp71 This polyfill detects features unavailable in releases prior to PHP 7.1 Available since release 6.4.0","title":"PHP 7.1"},{"location":"01_Components/05_Polyfills/Features/#php-72","text":"Polyfill class name Description SymfonyPhp72 This polyfill detects features unavailable in releases prior to PHP 7.2 Available since release 6.4.0","title":"PHP 7.2"},{"location":"01_Components/05_Polyfills/Features/#php-73","text":"Polyfill class name Description SymfonyPhp73 This polyfill detects features unavailable in releases prior to PHP 7.3 Available since release 6.4.0","title":"PHP 7.3"},{"location":"01_Components/05_Polyfills/Features/#php-74","text":"Polyfill class name Description SymfonyPhp74 This polyfill detects features unavailable in releases prior to PHP 7.4 Available since release 6.4.0","title":"PHP 7.4"},{"location":"01_Components/05_Polyfills/Features/#php-80","text":"Polyfill class name Description SymfonyPhp80 This polyfill detects features unavailable in releases prior to PHP 8.0 Available since release 6.4.0","title":"PHP 8.0"},{"location":"01_Components/05_Polyfills/Features/#php-81","text":"Polyfill class name Description SymfonyPhp81 This polyfill detects features unavailable in releases prior to PHP 8.1 Available since release 6.4.0","title":"PHP 8.1"},{"location":"02_Configs/","text":"About Before version 5.4, PHP CompatInfo used JSON config file handled by PHP Reflect Api/V3/Config object, With version 5.4+, PHP CompatInfo uses now the Symfony DependencyInjection component. It allows you to standardize and centralize the way objects are constructed in console application. Read more how Setting up the Container with Configuration Files . Old plugin system can be replaced with the Bartlett\\CompatInfo\\Event\\Dispatcher\\EventDispatcher service. Default version add two subscribers ( ProfileEventSubscriber and LogEventSubscriber ) to listen and handle all Application events.","title":"About"},{"location":"02_Configs/#about","text":"Before version 5.4, PHP CompatInfo used JSON config file handled by PHP Reflect Api/V3/Config object, With version 5.4+, PHP CompatInfo uses now the Symfony DependencyInjection component. It allows you to standardize and centralize the way objects are constructed in console application. Read more how Setting up the Container with Configuration Files . Old plugin system can be replaced with the Bartlett\\CompatInfo\\Event\\Dispatcher\\EventDispatcher service. Default version add two subscribers ( ProfileEventSubscriber and LogEventSubscriber ) to listen and handle all Application events.","title":"About"},{"location":"02_Configs/Default/","text":"Default Services and Parameters The closure returned by config/default.php file allows loading the following services: Service ID Service Class Description Symfony\\Component\\Console\\Input\\InputInterface Bartlett\\CompatInfo\\Console\\Input\\Input Represents an input coming from the CLI arguments Symfony\\Component\\Console\\Output\\OutputInterface Bartlett\\CompatInfo\\Console\\Output\\Output Is the default class for all CLI output Symfony\\Component\\Stopwatch\\Stopwatch Symfony\\Component\\Stopwatch\\Stopwatch Provides a way to profile your code analysis Psr\\Log\\LoggerInterface Bartlett\\CompatInfo\\Logger\\DefaultLogger Provides a default PSR3 compatible logger Bartlett\\CompatInfo\\Event\\Subscriber\\ProfileEventSubscriber Bartlett\\CompatInfo\\Event\\Subscriber\\ProfileEventSubscriber Subscriber that provides listeners to profile console commands Bartlett\\CompatInfo\\Event\\Subscriber\\LogEventSubscriber Bartlett\\CompatInfo\\Event\\Subscriber\\LogEventSubscriber Subscriber that provides listeners to log all application events Symfony\\Component\\EventDispatcher\\EventDispatcherInterface Bartlett\\CompatInfo\\Event\\Dispatcher\\EventDispatcher Dispatcher that handle all listeners attached by two subscribers Provides also some parameters for the PSR3 logger: Parameter ID Description app.log_stream_path Path to a local file app.log_channel Channel name app.log_level Minimum logging level that will be handled","title":"Default"},{"location":"02_Configs/Default/#default-services-and-parameters","text":"The closure returned by config/default.php file allows loading the following services: Service ID Service Class Description Symfony\\Component\\Console\\Input\\InputInterface Bartlett\\CompatInfo\\Console\\Input\\Input Represents an input coming from the CLI arguments Symfony\\Component\\Console\\Output\\OutputInterface Bartlett\\CompatInfo\\Console\\Output\\Output Is the default class for all CLI output Symfony\\Component\\Stopwatch\\Stopwatch Symfony\\Component\\Stopwatch\\Stopwatch Provides a way to profile your code analysis Psr\\Log\\LoggerInterface Bartlett\\CompatInfo\\Logger\\DefaultLogger Provides a default PSR3 compatible logger Bartlett\\CompatInfo\\Event\\Subscriber\\ProfileEventSubscriber Bartlett\\CompatInfo\\Event\\Subscriber\\ProfileEventSubscriber Subscriber that provides listeners to profile console commands Bartlett\\CompatInfo\\Event\\Subscriber\\LogEventSubscriber Bartlett\\CompatInfo\\Event\\Subscriber\\LogEventSubscriber Subscriber that provides listeners to log all application events Symfony\\Component\\EventDispatcher\\EventDispatcherInterface Bartlett\\CompatInfo\\Event\\Dispatcher\\EventDispatcher Dispatcher that handle all listeners attached by two subscribers Provides also some parameters for the PSR3 logger: Parameter ID Description app.log_stream_path Path to a local file app.log_channel Channel name app.log_level Minimum logging level that will be handled","title":"Default Services and Parameters"},{"location":"02_Configs/None/","text":"None Services and Parameters The closure returned by config/none.php file allows only loading the main Application service, and nothing else.","title":"None"},{"location":"02_Configs/None/#none-services-and-parameters","text":"The closure returned by config/none.php file allows only loading the main Application service, and nothing else.","title":"None Services and Parameters"},{"location":"03_Conditional_Code/100_Limitation/","text":"Limitation // @link https://github.com/nikic/PHP-Parser/blob/v4.10.0/lib/PhpParser/Lexer.php#L413-L433 $compatTokens = [ // PHP 7.4 'T_BAD_CHARACTER', 'T_FN', 'T_COALESCE_EQUAL', // PHP 8.0 'T_NAME_QUALIFIED', 'T_NAME_FULLY_QUALIFIED', 'T_NAME_RELATIVE', 'T_MATCH', 'T_NULLSAFE_OBJECT_OPERATOR', 'T_ATTRIBUTE', ]; foreach ($compatTokens as $token) { if (\\defined($token)) { $tokenId = \\constant($token); } } Here we cannot detect that constants listed in $compatTokens array are perhaps condition code. Later, in another script or even the same one, if we used these constants we will detect them as PHP 7.4 or PHP 8.0 versions, but it's not the reality. Example with // @link https://github.com/nikic/PHP-Parser/blob/v4.10.0/lib/PhpParser/Lexer.php#L110 $tokens[] = [\\T_BAD_CHARACTER, $chr, $line]; Console output tell us Constants Analysis Constant REF EXT min/Max PHP min/Max T_ABSTRACT tokenizer 5.0.0 5.0.0 T_ARRAY tokenizer 4.2.0 4.2.0 T_AS tokenizer 4.2.0 4.2.0 T_ATTRIBUTE user 4.0.0 T_BAD_CHARACTER tokenizer 7.4.0 7.4.0beta1 T_BREAK tokenizer 4.2.0 4.2.0 ... more ... true Core 4.0.0 4.0.0 Total [98] 7.4.0beta1 No condition found Requires PHP 7.4.0beta1 (min) Caution when you read such results. Until a new CompatInfo version is able to check this situation for us !","title":"Some Limitation"},{"location":"03_Conditional_Code/100_Limitation/#limitation","text":"// @link https://github.com/nikic/PHP-Parser/blob/v4.10.0/lib/PhpParser/Lexer.php#L413-L433 $compatTokens = [ // PHP 7.4 'T_BAD_CHARACTER', 'T_FN', 'T_COALESCE_EQUAL', // PHP 8.0 'T_NAME_QUALIFIED', 'T_NAME_FULLY_QUALIFIED', 'T_NAME_RELATIVE', 'T_MATCH', 'T_NULLSAFE_OBJECT_OPERATOR', 'T_ATTRIBUTE', ]; foreach ($compatTokens as $token) { if (\\defined($token)) { $tokenId = \\constant($token); } } Here we cannot detect that constants listed in $compatTokens array are perhaps condition code. Later, in another script or even the same one, if we used these constants we will detect them as PHP 7.4 or PHP 8.0 versions, but it's not the reality. Example with // @link https://github.com/nikic/PHP-Parser/blob/v4.10.0/lib/PhpParser/Lexer.php#L110 $tokens[] = [\\T_BAD_CHARACTER, $chr, $line]; Console output tell us Constants Analysis Constant REF EXT min/Max PHP min/Max T_ABSTRACT tokenizer 5.0.0 5.0.0 T_ARRAY tokenizer 4.2.0 4.2.0 T_AS tokenizer 4.2.0 4.2.0 T_ATTRIBUTE user 4.0.0 T_BAD_CHARACTER tokenizer 7.4.0 7.4.0beta1 T_BREAK tokenizer 4.2.0 4.2.0 ... more ... true Core 4.0.0 4.0.0 Total [98] 7.4.0beta1 No condition found Requires PHP 7.4.0beta1 (min) Caution when you read such results. Until a new CompatInfo version is able to check this situation for us !","title":"Limitation"},{"location":"03_Conditional_Code/1_Introduction/","text":"Introduction What is considered as a conditional code ? Each time you found following functions in source code : extension_loaded function_exists method_exists class_exists interface_exists trait_exists defined Note for developers, this is the Bartlett\\CompatInfo\\Sniffs\\Expressions\\ConditionalCodeSniff sniff that handle it ! This feature was improve since previous versions until 5.4, but has some limits you should know. if we detect one of these previous function, we do not compute php.min , php.max , ext.* version elements to global or parent results. That means, with this code : <?php Class C { function encode () { if ( ! function_exists ( 'json_encode' )) { function json_encode ( $value , $options = 0 , $depth = 512 ) { // ... do something } } } } When we run analyser, we got this output : Data Source Analysed Directories 1 Files 1 Errors 0 Extensions Analysis Extension REF EXT min/Max PHP min/Max Core Core 4.0.0 4.0.0 C json json 5.2.0 5.2.0 Total [2] 4.0.0 Namespaces Analysis Namespace REF EXT min/Max PHP min/Max Core 4.0.0 Total [1] 4.0.0 No interface found No trait found Classes Analysis Class REF EXT min/Max PHP min/Max C user 4.0.0 Total [1] 4.0.0 No generator found Functions Analysis Function REF EXT min/Max PHP min/Max C\\encode\\json_encode user 4.0.0 function_exists Core 4.0.0 4.0.0 C json_encode json 5.2.0 5.2.0 Total [3] 4.0.0 No constant found Conditions Analysis Condition REF EXT min/Max PHP min/Max function_exists(json_encode) json 5.2.0 5.2.0 Total [1] 5.2.0 Requires PHP 4.0.0 (min) Each data with a C in front of line tell us that the code is conditional. json_encode native function that come with PHP 7.2 is only used for PHP 7.2 or greater and the user function C\\encode\\json_encode is used for PHP versions less or equal 7.1.* This is a very simple example. There are much more difficult situation that CompatInfo can handle, and some that we cannot !","title":"Introduction"},{"location":"03_Conditional_Code/1_Introduction/#introduction","text":"What is considered as a conditional code ? Each time you found following functions in source code : extension_loaded function_exists method_exists class_exists interface_exists trait_exists defined Note for developers, this is the Bartlett\\CompatInfo\\Sniffs\\Expressions\\ConditionalCodeSniff sniff that handle it ! This feature was improve since previous versions until 5.4, but has some limits you should know. if we detect one of these previous function, we do not compute php.min , php.max , ext.* version elements to global or parent results. That means, with this code : <?php Class C { function encode () { if ( ! function_exists ( 'json_encode' )) { function json_encode ( $value , $options = 0 , $depth = 512 ) { // ... do something } } } } When we run analyser, we got this output : Data Source Analysed Directories 1 Files 1 Errors 0 Extensions Analysis Extension REF EXT min/Max PHP min/Max Core Core 4.0.0 4.0.0 C json json 5.2.0 5.2.0 Total [2] 4.0.0 Namespaces Analysis Namespace REF EXT min/Max PHP min/Max Core 4.0.0 Total [1] 4.0.0 No interface found No trait found Classes Analysis Class REF EXT min/Max PHP min/Max C user 4.0.0 Total [1] 4.0.0 No generator found Functions Analysis Function REF EXT min/Max PHP min/Max C\\encode\\json_encode user 4.0.0 function_exists Core 4.0.0 4.0.0 C json_encode json 5.2.0 5.2.0 Total [3] 4.0.0 No constant found Conditions Analysis Condition REF EXT min/Max PHP min/Max function_exists(json_encode) json 5.2.0 5.2.0 Total [1] 5.2.0 Requires PHP 4.0.0 (min) Each data with a C in front of line tell us that the code is conditional. json_encode native function that come with PHP 7.2 is only used for PHP 7.2 or greater and the user function C\\encode\\json_encode is used for PHP versions less or equal 7.1.* This is a very simple example. There are much more difficult situation that CompatInfo can handle, and some that we cannot !","title":"Introduction"},{"location":"03_Conditional_Code/2_Indirect_Call/","text":"Indirect calls By indirect calls, CompatInfo is unable (yet) to resolve such type of code. $ext = 'intl'; if (extension_loaded($ext)) { // ... do something } extension_loaded is well detected but not the extension name.","title":"Indirect Call"},{"location":"03_Conditional_Code/2_Indirect_Call/#indirect-calls","text":"By indirect calls, CompatInfo is unable (yet) to resolve such type of code. $ext = 'intl'; if (extension_loaded($ext)) { // ... do something } extension_loaded is well detected but not the extension name.","title":"Indirect calls"},{"location":"03_Conditional_Code/3_Multiple_Signature/","text":"Multiple signatures Face to this source code, CompatInfo is unable to know what idn_to_ascii signature is the minimum. if (function_exists('idn_to_ascii')) { if (defined('INTL_IDNA_VARIANT_UTS46')) { $domain = idn_to_ascii($domain, 0, INTL_IDNA_VARIANT_UTS46); } else { $domain = idn_to_ascii($domain); } } We know ( idn_to_ascii changelog ) that by using $variant parameter, the minimum PHP version required is 7.4.0 , otherwise it's only 5.2.4 So the console output look like Data Source Analysed Directories 1 Files 1 Errors 0 Extensions Analysis Extension REF EXT min/Max PHP min/Max Core Core 4.0.0 4.0.0 C intl intl 2.0.0b1 5.2.4 Total [2] 4.0.0 Namespaces Analysis Namespace REF EXT min/Max PHP min/Max Core 4.0.0 Total [1] 4.0.0 No interface found No trait found No class found No generator found Functions Analysis Function REF EXT min/Max PHP min/Max defined Core 4.0.0 4.0.0 function_exists Core 4.0.0 4.0.0 C idn_to_ascii intl 1.0.2 5.2.4 Total [3] 4.0.0 Constants Analysis Constant REF EXT min/Max PHP min/Max C INTL_IDNA_VARIANT_UTS46 intl 2.0.0b1 5.2.4 Total [1] 4.0.0 Conditions Analysis Condition REF EXT min/Max PHP min/Max defined(INTL_IDNA_VARIANT_UTS46) intl 2.0.0b1 5.2.4 function_exists(idn_to_ascii) intl 1.0.2 5.2.4 Total [2] 5.2.4 Requires PHP 4.0.0 (min)","title":"Multiple Signature"},{"location":"03_Conditional_Code/3_Multiple_Signature/#multiple-signatures","text":"Face to this source code, CompatInfo is unable to know what idn_to_ascii signature is the minimum. if (function_exists('idn_to_ascii')) { if (defined('INTL_IDNA_VARIANT_UTS46')) { $domain = idn_to_ascii($domain, 0, INTL_IDNA_VARIANT_UTS46); } else { $domain = idn_to_ascii($domain); } } We know ( idn_to_ascii changelog ) that by using $variant parameter, the minimum PHP version required is 7.4.0 , otherwise it's only 5.2.4 So the console output look like Data Source Analysed Directories 1 Files 1 Errors 0 Extensions Analysis Extension REF EXT min/Max PHP min/Max Core Core 4.0.0 4.0.0 C intl intl 2.0.0b1 5.2.4 Total [2] 4.0.0 Namespaces Analysis Namespace REF EXT min/Max PHP min/Max Core 4.0.0 Total [1] 4.0.0 No interface found No trait found No class found No generator found Functions Analysis Function REF EXT min/Max PHP min/Max defined Core 4.0.0 4.0.0 function_exists Core 4.0.0 4.0.0 C idn_to_ascii intl 1.0.2 5.2.4 Total [3] 4.0.0 Constants Analysis Constant REF EXT min/Max PHP min/Max C INTL_IDNA_VARIANT_UTS46 intl 2.0.0b1 5.2.4 Total [1] 4.0.0 Conditions Analysis Condition REF EXT min/Max PHP min/Max defined(INTL_IDNA_VARIANT_UTS46) intl 2.0.0b1 5.2.4 function_exists(idn_to_ascii) intl 1.0.2 5.2.4 Total [2] 5.2.4 Requires PHP 4.0.0 (min)","title":"Multiple signatures"},{"location":"04_Exclude_Folders/","text":"About Two different ways to exclude directories from scan. With Console (CLI) Since version 5.5.2, you can provide the new --exclude option. This option accept multiple values as shown next: bin/phpcompatinfo analyser:run . --exclude vendor --exclude tests With php script (API) require_once 'config/bootstrap.php'; use Bartlett\\CompatInfo\\Application\\Profiler\\Profile; use Bartlett\\CompatInfo\\Application\\Query\\Analyser\\Compatibility\\GetCompatibilityQuery; use Bartlett\\CompatInfo\\Application\\Query\\QueryBusInterface; use Symfony\\Component\\Messenger\\Exception\\HandlerFailedException; $container = require 'config/container.php'; $queryBus = $container->get(QueryBusInterface::class); // perform request, on a data source with default analyser $dataSource = __DIR__; // exclude some folders from scanning $excludeDirs = ['vendor', 'tests']; // equivalent to CLI command `phpcompatinfo analyser:run . --exclude vendor --exclude tests` $compatibilityQuery = new GetCompatibilityQuery($dataSource, $excludeDirs, false); try { /** @var Profile $profile */ $profile = $queryBus->query($compatibilityQuery); $data = $profile->getData(); $dump = reset($data); var_export($dump); } catch (HandlerFailedException $e) { foreach ($e->getNestedExceptions() as $ex) { printf('Exception -- %s >> %s%s' . $ex->getMessage(), $ex->getTraceAsString(), PHP_EOL); }; }","title":"Exclude Directories"},{"location":"04_Exclude_Folders/#about","text":"Two different ways to exclude directories from scan.","title":"About"},{"location":"04_Exclude_Folders/#with-console-cli","text":"Since version 5.5.2, you can provide the new --exclude option. This option accept multiple values as shown next: bin/phpcompatinfo analyser:run . --exclude vendor --exclude tests","title":"With Console (CLI)"},{"location":"04_Exclude_Folders/#with-php-script-api","text":"require_once 'config/bootstrap.php'; use Bartlett\\CompatInfo\\Application\\Profiler\\Profile; use Bartlett\\CompatInfo\\Application\\Query\\Analyser\\Compatibility\\GetCompatibilityQuery; use Bartlett\\CompatInfo\\Application\\Query\\QueryBusInterface; use Symfony\\Component\\Messenger\\Exception\\HandlerFailedException; $container = require 'config/container.php'; $queryBus = $container->get(QueryBusInterface::class); // perform request, on a data source with default analyser $dataSource = __DIR__; // exclude some folders from scanning $excludeDirs = ['vendor', 'tests']; // equivalent to CLI command `phpcompatinfo analyser:run . --exclude vendor --exclude tests` $compatibilityQuery = new GetCompatibilityQuery($dataSource, $excludeDirs, false); try { /** @var Profile $profile */ $profile = $queryBus->query($compatibilityQuery); $data = $profile->getData(); $dump = reset($data); var_export($dump); } catch (HandlerFailedException $e) { foreach ($e->getNestedExceptions() as $ex) { printf('Exception -- %s >> %s%s' . $ex->getMessage(), $ex->getTraceAsString(), PHP_EOL); }; }","title":"With php script (API)"},{"location":"99_Architecture/application/","text":"Application Layer Analyser(s) Collection(s) Data Collector(s) Event(s) Extension(s) Logger Parser Polyfill(s) Profiler Query(s) Service(s) Sniff(s)","title":"Application"},{"location":"99_Architecture/application/#application-layer","text":"","title":"Application Layer"},{"location":"99_Architecture/application/#analysers","text":"","title":"Analyser(s)"},{"location":"99_Architecture/application/#collections","text":"","title":"Collection(s)"},{"location":"99_Architecture/application/#data-collectors","text":"","title":"Data Collector(s)"},{"location":"99_Architecture/application/#events","text":"","title":"Event(s)"},{"location":"99_Architecture/application/#extensions","text":"","title":"Extension(s)"},{"location":"99_Architecture/application/#logger","text":"","title":"Logger"},{"location":"99_Architecture/application/#parser","text":"","title":"Parser"},{"location":"99_Architecture/application/#polyfills","text":"","title":"Polyfill(s)"},{"location":"99_Architecture/application/#profiler","text":"","title":"Profiler"},{"location":"99_Architecture/application/#querys","text":"","title":"Query(s)"},{"location":"99_Architecture/application/#services","text":"","title":"Service(s)"},{"location":"99_Architecture/application/#sniffs","text":"","title":"Sniff(s)"},{"location":"99_Architecture/infrastructure/","text":"Infrastructure Layer Bus Framework","title":"Infrastructure"},{"location":"99_Architecture/infrastructure/#infrastructure-layer","text":"","title":"Infrastructure Layer"},{"location":"99_Architecture/infrastructure/#bus","text":"","title":"Bus"},{"location":"99_Architecture/infrastructure/#framework","text":"","title":"Framework"},{"location":"99_Architecture/presentation/","text":"Presentation Layer Console","title":"Presentation"},{"location":"99_Architecture/presentation/#presentation-layer","text":"","title":"Presentation Layer"},{"location":"99_Architecture/presentation/#console","text":"","title":"Console"}]}